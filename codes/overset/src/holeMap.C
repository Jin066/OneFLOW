//
// This file is part of the Tioga software library
//
// Tioga  is a tool for overset grid assembly on parallel distributed systems
// Copyright (C) 2015 Jay Sitaraman
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

#include <limits>
#include <vector>
#include <array>
#include "codetypes.h"
#include "tioga.h"
using namespace TIOGA;
extern "C" 
{ 
	;
}

void fillHoleMap(int *holeMap, int ix[3], int isym);

/**
 * Create hole maps for all grids
 * this routine is not efficient
 * since it does mutiple global reduce ops
 * have to change it at a later date when
 * there is more time to develop code
 */
void tioga::getHoleMap(void)  //洞映射
{
  int i,j,k,m;
  int ii,jj,kk;
  // double wbox[6]; //墙边界箱[6]
  std::vector<std::array<double,6>> wbox(nblocks);
  //int existWall; //有墙存在
  std::vector<int> existWall(nblocks);
  int meshtag,maxtag, mtagtmp;
  int *existHoleLocal;   //存在本地洞
  int *existHole;    //存在洞
  double *bboxLocal;   //本地边界箱
  double *bboxGlobal;  //全局边界箱
  double ds[3],dsmax,dsbox;
  int bufferSize;     //缓冲区大小(需要发送或接收的边界箱三个方向的子块数的乘积)
  FILE *fp;
  char fname[80];
  char intstring[7];//
 //
 // get the local bounding box  得到本地边界箱
 //
  meshtag = -BIGINT; //std::numeric_limits<int>::lowest();
  for (int i=0; i<nblocks; i++) {
    auto& mb = mblocks[i]; //网格块索引
    mb->getWallBounds(&mtagtmp,&existWall[i],wbox[i].data()); //得到壁边界箱（壁面边界箱的最大和最小坐标）
    if (mtagtmp > meshtag) meshtag = mtagtmp;
  }
  MPI_Allreduce(&meshtag,&maxtag,1,MPI_INT,MPI_MAX,scomm);
 //
 if (holeMap) //如果存在洞map
   {
     for(i=0;i<nmesh;i++)
       if (holeMap[i].existWall) TIOGA_FREE(holeMap[i].sam);  //如果existWall=1，壁边界存在，则将SAM辅助网格置零
     delete [] holeMap;
   }
 holeMap=new HOLEMAP[maxtag];
 //
 existHoleLocal=(int *)malloc(sizeof(int)*maxtag); //本地的洞
 existHole=(int *)malloc(sizeof(int)*maxtag); 
 //
 for(i=0;i<maxtag;i++) existHole[i]=existHoleLocal[i]=0; //初始值existHole和existHoleLocal=0
 //
 for (int i=0; i<nblocks; i++) {
   existHoleLocal[mtags[i]-1]=existWall[i];    //existHoleLocal=existWall
 }
 //
 MPI_Allreduce(existHoleLocal,existHole,maxtag,MPI_INT,MPI_MAX,scomm);
 //
 for(i=0;i<maxtag;i++) holeMap[i].existWall=existHole[i];
 //
 bboxLocal=(double *) malloc(sizeof(double)*6*maxtag); //壁面边界箱范围（本地）（包含最大和最小坐标）
 bboxGlobal=(double *) malloc(sizeof(double)*6*maxtag); //壁面边界箱范围（全局）
 //
 for(i=0;i<3*maxtag;i++) bboxLocal[i]=BIGVALUE; //边界箱(本地)最大坐标值存储
 for(i=0;i<3*maxtag;i++) bboxLocal[i+3*maxtag]=-BIGVALUE; //边界箱(本地)最小坐标存储
 for(i=0;i<3*maxtag;i++) bboxGlobal[i]=BIGVALUE; //边界箱(全局)最大坐标值存储
 for(i=0;i<3*maxtag;i++) bboxGlobal[i+3*maxtag]=-BIGVALUE;//边界箱(全局)最小坐标值存储

 //
 for (int n=0; n<nblocks; n++) {
   meshtag = mtags[n];
   for (i = 0; i < 3; i++) {
     bboxLocal[3 * (meshtag - 1) + i] = wbox[n][i];  //该网格的边界箱的最大值
     bboxLocal[3 * (meshtag - 1) + i + 3 * maxtag] = wbox[n][i + 3]; //该网格的边界箱的最小值
   }
 }
 //
 // get the global bounding box info across all the
 // partitions for all meshes  //获取所有网格的所有分区的全局边界框信息
 //
 MPI_Allreduce(bboxLocal, bboxGlobal, 3 * maxtag, MPI_DOUBLE, MPI_MIN, scomm);
 MPI_Allreduce(&(bboxLocal[3 * maxtag]), &(bboxGlobal[3 * maxtag]), 3 * maxtag, MPI_DOUBLE,
   MPI_MAX, scomm);
 //
 // find the bounding box for each mesh
 // from the globally reduced data  从全局简化的数据中找到每个网格的包围框
 //
 for (i = 0; i < maxtag; i++) {
   if (holeMap[i].existWall) {
     for (j = 0; j < 3; j++) {
       holeMap[i].extents[j] = bboxGlobal[3 * i + j]; //边界箱（全局）最大值
       holeMap[i].extents[j + 3] = bboxGlobal[3 * i + j + 3 * maxtag]; //边界箱（全局）最小值
       ds[j] = holeMap[i].extents[j + 3] - holeMap[i].extents[j]; //边界框跨度（在三个坐标方向）
     }
     dsmax = TIOGA_MAX(ds[0], ds[1]);
     dsmax = TIOGA_MAX(dsmax, ds[2]); //三个坐标方向上，边界框最大跨度
     dsbox = dsmax / HOLEMAPSIZE;//边界框跨度最大方向子块的尺寸

     for (j = 0; j < 3; j++) {
       holeMap[i].extents[j] -= (2 * dsbox); //边界框最大坐标值 - 2倍子块尺寸，缩小边界框
       holeMap[i].extents[j + 3] += (2 * dsbox); //边界框最小值 + 2倍子块尺寸
       holeMap[i].nx[j] = floor(
         TIOGA_MAX((holeMap[i].extents[j + 3] - holeMap[i].extents[j]) / dsbox, 1));  //三个方向上边界框中子块的数量（结构辅助网格）
     }
     bufferSize = holeMap[i].nx[0] * holeMap[i].nx[1] * holeMap[i].nx[2];  //缓冲区大小(三个方向的子块数的乘积)
     holeMap[i].sam = (int*)malloc(sizeof(int) * bufferSize); //结构辅助网格，大小=bufferSize
     holeMap[i].samLocal = (int*)malloc(sizeof(int) * bufferSize); //本地结构辅助网格，大小=bufferSize
     for (j = 0; j < bufferSize; j++)
       holeMap[i].sam[j] = holeMap[i].samLocal[j] = 0; //将辅助网格子块单元置零
   }
 }
 //
 // mark the wall boundary cells in the holeMap在洞图上标记墙上的边界单元
 //
 for (int ib=0;ib<nblocks;ib++) {
   auto& mb = mblocks[ib]; 
   meshtag = mb->getMeshTag(); //得到网格标签
   if (holeMap[meshtag - 1].existWall) { //判断是否存在边界
    mb->markWallBoundary(
      holeMap[meshtag - 1].samLocal, holeMap[meshtag - 1].nx,
      holeMap[meshtag - 1].extents); //标记墙边界子块（本地SAM,SAM三坐标轴方向子块个数，SAM范围（最大和最小坐标））
   }
 }
 //
 // allreduce the holeMap of each mesh 简化每个网格的洞图
 //
 for(i=0;i<maxtag;i++) //循环每一个网格
   {
    if (holeMap[i].existWall) //如果存在墙边界
     {
      bufferSize=holeMap[i].nx[0]*holeMap[i].nx[1]*holeMap[i].nx[2]; //在洞的边界框内的子块个数
      MPI_Allreduce(holeMap[i].samLocal,holeMap[i].sam,bufferSize,MPI_INT,MPI_MAX,scomm); //
     }
   }
 //
 for(i=0;i<maxtag;i++)
   if (holeMap[i].existWall) TIOGA_FREE(holeMap[i].samLocal); //置零
 //
 // set the global number of meshes to maxtag 将全局网格数设置为maxtag
 //
 nmesh=maxtag;
 //
 // now fill the holeMap 现在把洞图填满
 //
 for(i=0;i<maxtag;i++)
   if (holeMap[i].existWall) fillHoleMap(holeMap[i].sam,holeMap[i].nx,isym); //如果存在墙边界（墙边界子块已标记完），则执行填充操作
 //
 // output the hole map输出洞图
 //
 //this->outputHoleMap();
 //
 // free local memory
 //
 TIOGA_FREE(existHoleLocal);
 TIOGA_FREE(existHole);
 TIOGA_FREE(bboxLocal);
 TIOGA_FREE(bboxGlobal);
}

/**
 * Output the hole map to a tecplot compatible file
*/
void tioga::outputHoleMap(void)
{
  int i,k;
  int nnodes,ncells;
  int ns1,ns2;
  int ii,jj,kk,m;
  FILE *fp;
  double ds[3];
  char intstring[7];
  char fname[80];

  for(i=0;i<nmesh;i++)
    if (holeMap[i].existWall)
       {
	 sprintf(intstring,"%d",100000+i+100*myid);
	 sprintf(fname,"holeMap%s.dat",&(intstring[1]));
	 fp=fopen(fname,"w");
	 fprintf(fp,"TITLE =\"Tioga output\"\n");
	 fprintf(fp,"VARIABLES=\"X\",\"Y\",\"Z\",\"IBLANK\"\n");
	 nnodes=(holeMap[i].nx[0]+1)*(holeMap[i].nx[1]+1)*(holeMap[i].nx[2]+1);
	 ncells=(holeMap[i].nx[0])*(holeMap[i].nx[1])*(holeMap[i].nx[2]);	 
	 fprintf(fp,"ZONE T=\"VOL_MIXED\",N=%d E=%d ET=BRICK, F=FEBLOCK\n",nnodes,ncells);
	 fprintf(fp,"VARLOCATION = (1=NODAL, 2=NODAL, 3=NODAL, 4=CELLCENTERED)\n");
	 for(k=0;k<3;k++) ds[k]=(holeMap[i].extents[k+3]-holeMap[i].extents[k])/(holeMap[i].nx[k]);
	 //
	 for(kk=0;kk<holeMap[i].nx[2]+1;kk++)
	   for(jj=0;jj<holeMap[i].nx[1]+1;jj++)
	     for(ii=0;ii<holeMap[i].nx[0]+1;ii++)
	       fprintf(fp,"%.14e\n",ii*ds[0]);
	 for(kk=0;kk<holeMap[i].nx[2]+1;kk++)
	   for(jj=0;jj<holeMap[i].nx[1]+1;jj++)
	     for(ii=0;ii<holeMap[i].nx[0]+1;ii++)
	       fprintf(fp,"%.14e\n",jj*ds[1]);
	 for(kk=0;kk<holeMap[i].nx[2]+1;kk++)
	   for(jj=0;jj<holeMap[i].nx[1]+1;jj++)
	     for(ii=0;ii<holeMap[i].nx[0]+1;ii++)
	       fprintf(fp,"%.14e\n",kk*ds[2]);
	 m=0;
	 for(kk=0;kk<holeMap[i].nx[2];kk++)
	   for(jj=0;jj<holeMap[i].nx[1];jj++)
	     for(ii=0;ii<holeMap[i].nx[0];ii++)
	       {
		 fprintf(fp,"%f\n",(double)holeMap[i].sam[m]);
		 m++;
	       }
	 
	 m=0;
         ns1=holeMap[i].nx[0]+1;
	 ns2=(holeMap[i].nx[1]+1)*ns1;
	 for(kk=0;kk<holeMap[i].nx[2];kk++)
	   for(jj=0;jj<holeMap[i].nx[1];jj++)
	     for(ii=0;ii<holeMap[i].nx[0];ii++)
	       {
		 m=kk*ns2+jj*ns1+ii+1;
		 fprintf(fp,"%d %d %d %d %d %d %d %d\n",m,m+1,m+1+ns1,m+ns1,
			 m+ns2,m+1+ns2,m+ns2+ns1+1,m+ns1+ns2);
	       }
       }
 fclose(fp);
}
	 
